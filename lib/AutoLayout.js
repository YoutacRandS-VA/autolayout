(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@lume/kiwi')) :
    typeof define === 'function' && define.amd ? define(['exports', '@lume/kiwi'], factory) :
    (global = global || self, factory(global.AutoLayout = {}, global.kiwi));
}(this, function (exports, kiwi) { 'use strict';

    /**
     * Layout attributes.
     * @enum {String}
     */
    var Attribute = {
        CONST: 'const',
        NOTANATTRIBUTE: 'const',
        VARIABLE: 'var',
        LEFT: 'left',
        RIGHT: 'right',
        TOP: 'top',
        BOTTOM: 'bottom',
        WIDTH: 'width',
        HEIGHT: 'height',
        CENTERX: 'centerX',
        CENTERY: 'centerY',
        /*LEADING: 'leading',
        TRAILING: 'trailing'*/
        /** Used by the extended VFL syntax. */
        ZINDEX: 'zIndex',
    };

    /**
     * Relation types.
     * @enum {String}
     */
    var Relation = {
        /** Less than or equal */
        LEQ: 'leq',
        /** Equal */
        EQU: 'equ',
        /** Greater than or equal */
        GEQ: 'geq',
    };

    /**
     * Layout priorities.
     * @enum {String}
     */
    var Priority = {
        REQUIRED: 1000,
        DEFAULTHIGH: 750,
        DEFAULTLOW: 250,
        //FITTINGSIZELEVEL: 50,
    };

    var parser = (function () {
        /*
         * Generated by PEG.js 0.8.0.
         *
         * http://pegjs.majda.cz/
         */
        function peg$subclass(child, parent) {
            function ctor() { this.constructor = child; }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
        }
        function SyntaxError(message, expected, found, offset, line, column) {
            this.message = message;
            this.expected = expected;
            this.found = found;
            this.offset = offset;
            this.line = line;
            this.column = column;
            this.name = "SyntaxError";
        }
        peg$subclass(SyntaxError, Error);
        function parse(input) {
            var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { visualFormatString: peg$parsevisualFormatString }, peg$startRuleFunction = peg$parsevisualFormatString, peg$c0 = peg$FAILED, peg$c1 = null, peg$c2 = ":", peg$c3 = { type: "literal", value: ":", description: "\":\"" }, peg$c5 = function (o, superto, view, views, tosuper) {
                return {
                    orientation: o ? o[0] : 'horizontal',
                    cascade: (superto || []).concat([view], [].concat.apply([], views), (tosuper || []))
                };
            }, peg$c6 = "H", peg$c7 = { type: "literal", value: "H", description: "\"H\"" }, peg$c8 = "V", peg$c9 = { type: "literal", value: "V", description: "\"V\"" }, peg$c10 = function (orient) { return orient == 'H' ? 'horizontal' : 'vertical'; }, peg$c11 = "|", peg$c12 = { type: "literal", value: "|", description: "\"|\"" }, peg$c13 = function () { return { view: null }; }, peg$c14 = "[", peg$c15 = { type: "literal", value: "[", description: "\"[\"" }, peg$c16 = "]", peg$c17 = { type: "literal", value: "]", description: "\"]\"" }, peg$c18 = function (view, predicates) { return extend(view, predicates ? { constraints: predicates } : {}); }, peg$c19 = "-", peg$c20 = { type: "literal", value: "-", description: "\"-\"" }, peg$c21 = function (predicateList) { return predicateList; }, peg$c22 = function () { return [{ relation: 'equ', constant: 'default', $parserOffset: offset() }]; }, peg$c23 = "", peg$c24 = function () { return [{ relation: 'equ', constant: 0, $parserOffset: offset() }]; }, peg$c25 = function (n) { return [{ relation: 'equ', constant: n, $parserOffset: offset() }]; }, peg$c26 = "(", peg$c27 = { type: "literal", value: "(", description: "\"(\"" }, peg$c28 = ",", peg$c29 = { type: "literal", value: ",", description: "\",\"" }, peg$c30 = ")", peg$c31 = { type: "literal", value: ")", description: "\")\"" }, peg$c32 = function (p, ps) { return [p].concat(ps.map(function (p) { return p[1]; })); }, peg$c33 = "@", peg$c34 = { type: "literal", value: "@", description: "\"@\"" }, peg$c35 = function (r, o, p) { return extend({ relation: 'equ' }, (r || {}), o, (p ? p[1] : {})); }, peg$c36 = "==", peg$c37 = { type: "literal", value: "==", description: "\"==\"" }, peg$c38 = function () { return { relation: 'equ', $parserOffset: offset() }; }, peg$c39 = "<=", peg$c40 = { type: "literal", value: "<=", description: "\"<=\"" }, peg$c41 = function () { return { relation: 'leq', $parserOffset: offset() }; }, peg$c42 = ">=", peg$c43 = { type: "literal", value: ">=", description: "\">=\"" }, peg$c44 = function () { return { relation: 'geq', $parserOffset: offset() }; }, peg$c45 = /^[0-9]/, peg$c46 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c47 = function (digits) { return { priority: parseInt(digits.join(""), 10) }; }, peg$c48 = function (n) { return { constant: n }; }, peg$c49 = /^[a-zA-Z_]/, peg$c50 = { type: "class", value: "[a-zA-Z_]", description: "[a-zA-Z_]" }, peg$c51 = /^[a-zA-Z0-9_]/, peg$c52 = { type: "class", value: "[a-zA-Z0-9_]", description: "[a-zA-Z0-9_]" }, peg$c53 = function (f, v) { return { view: f + v }; }, peg$c54 = ".", peg$c55 = { type: "literal", value: ".", description: "\".\"" }, peg$c56 = function (digits, decimals) { return parseFloat(digits.concat(".").concat(decimals).join(""), 10); }, peg$c57 = function (digits) { return parseInt(digits.join(""), 10); }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$result;
            if ("startRule" in options) {
                if (!(options.startRule in peg$startRuleFunctions)) {
                    throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                }
                peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
            }
            function offset() {
                return peg$reportedPos;
            }
            function peg$computePosDetails(pos) {
                function advance(details, startPos, endPos) {
                    var p, ch;
                    for (p = startPos; p < endPos; p++) {
                        ch = input.charAt(p);
                        if (ch === "\n") {
                            if (!details.seenCR) {
                                details.line++;
                            }
                            details.column = 1;
                            details.seenCR = false;
                        }
                        else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                            details.line++;
                            details.column = 1;
                            details.seenCR = true;
                        }
                        else {
                            details.column++;
                            details.seenCR = false;
                        }
                    }
                }
                if (peg$cachedPos !== pos) {
                    if (peg$cachedPos > pos) {
                        peg$cachedPos = 0;
                        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
                    }
                    advance(peg$cachedPosDetails, peg$cachedPos, pos);
                    peg$cachedPos = pos;
                }
                return peg$cachedPosDetails;
            }
            function peg$fail(expected) {
                if (peg$currPos < peg$maxFailPos) {
                    return;
                }
                if (peg$currPos > peg$maxFailPos) {
                    peg$maxFailPos = peg$currPos;
                    peg$maxFailExpected = [];
                }
                peg$maxFailExpected.push(expected);
            }
            function peg$buildException(message, expected, pos) {
                function cleanupExpected(expected) {
                    var i = 1;
                    expected.sort(function (a, b) {
                        if (a.description < b.description) {
                            return -1;
                        }
                        else if (a.description > b.description) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    });
                    while (i < expected.length) {
                        if (expected[i - 1] === expected[i]) {
                            expected.splice(i, 1);
                        }
                        else {
                            i++;
                        }
                    }
                }
                function buildMessage(expected, found) {
                    function stringEscape(s) {
                        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
                        return s
                            .replace(/\\/g, '\\\\')
                            .replace(/"/g, '\\"')
                            .replace(/\x08/g, '\\b')
                            .replace(/\t/g, '\\t')
                            .replace(/\n/g, '\\n')
                            .replace(/\f/g, '\\f')
                            .replace(/\r/g, '\\r')
                            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
                            .replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) { return '\\x' + hex(ch); })
                            .replace(/[\u0180-\u0FFF]/g, function (ch) { return '\\u0' + hex(ch); })
                            .replace(/[\u1080-\uFFFF]/g, function (ch) { return '\\u' + hex(ch); });
                    }
                    var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
                    for (i = 0; i < expected.length; i++) {
                        expectedDescs[i] = expected[i].description;
                    }
                    expectedDesc = expected.length > 1
                        ? expectedDescs.slice(0, -1).join(", ")
                            + " or "
                            + expectedDescs[expected.length - 1]
                        : expectedDescs[0];
                    foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
                    return "Expected " + expectedDesc + " but " + foundDesc + " found.";
                }
                var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
                if (expected !== null) {
                    cleanupExpected(expected);
                }
                return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
            }
            function peg$parsevisualFormatString() {
                var s0, s1, s2, s3, s4, s5, s6, s7;
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = peg$parseorientation();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                        s3 = peg$c2;
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        {
                            peg$fail(peg$c3);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s2 = [s2, s3];
                        s1 = s2;
                    }
                    else {
                        peg$currPos = s1;
                        s1 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$c0;
                }
                if (s1 === peg$FAILED) {
                    s1 = peg$c1;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parsesuperview();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseconnection();
                        if (s4 !== peg$FAILED) {
                            s3 = [s3, s4];
                            s2 = s3;
                        }
                        else {
                            peg$currPos = s2;
                            s2 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$c0;
                    }
                    if (s2 === peg$FAILED) {
                        s2 = peg$c1;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseview();
                        if (s3 !== peg$FAILED) {
                            s4 = [];
                            s5 = peg$currPos;
                            s6 = peg$parseconnection();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseview();
                                if (s7 !== peg$FAILED) {
                                    s6 = [s6, s7];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                            while (s5 !== peg$FAILED) {
                                s4.push(s5);
                                s5 = peg$currPos;
                                s6 = peg$parseconnection();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parseview();
                                    if (s7 !== peg$FAILED) {
                                        s6 = [s6, s7];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$c0;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = peg$currPos;
                                s6 = peg$parseconnection();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parsesuperview();
                                    if (s7 !== peg$FAILED) {
                                        s6 = [s6, s7];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$c0;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                                if (s5 === peg$FAILED) {
                                    s5 = peg$c1;
                                }
                                if (s5 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c5(s1, s2, s3, s4, s5);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseorientation() {
                var s0, s1;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 72) {
                    s1 = peg$c6;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c7);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 86) {
                        s1 = peg$c8;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c9);
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c10(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parsesuperview() {
                var s0, s1;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 124) {
                    s1 = peg$c11;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c12);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c13();
                }
                s0 = s1;
                return s0;
            }
            function peg$parseview() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                    s1 = peg$c14;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c15);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseviewName();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parsepredicateListWithParens();
                        if (s3 === peg$FAILED) {
                            s3 = peg$c1;
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 93) {
                                s4 = peg$c16;
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c17);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c18(s2, s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseconnection() {
                var s0, s1, s2, s3;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c19;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c20);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsepredicateList();
                    if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s3 = peg$c19;
                            peg$currPos++;
                        }
                        else {
                            s3 = peg$FAILED;
                            {
                                peg$fail(peg$c20);
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c21(s2);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s1 = peg$c19;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c20);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c22();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$c23;
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c24();
                        }
                        s0 = s1;
                    }
                }
                return s0;
            }
            function peg$parsepredicateList() {
                var s0;
                s0 = peg$parsesimplePredicate();
                if (s0 === peg$FAILED) {
                    s0 = peg$parsepredicateListWithParens();
                }
                return s0;
            }
            function peg$parsesimplePredicate() {
                var s0, s1;
                s0 = peg$currPos;
                s1 = peg$parsenumber();
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c25(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parsepredicateListWithParens() {
                var s0, s1, s2, s3, s4, s5, s6;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 40) {
                    s1 = peg$c26;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c27);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsepredicate();
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c28;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            {
                                peg$fail(peg$c29);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsepredicate();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s5 = peg$c28;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                {
                                    peg$fail(peg$c29);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parsepredicate();
                                if (s6 !== peg$FAILED) {
                                    s5 = [s5, s6];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s4 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c32(s2, s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parsepredicate() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                s1 = peg$parserelation();
                if (s1 === peg$FAILED) {
                    s1 = peg$c1;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseobjectOfPredicate();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 64) {
                            s4 = peg$c33;
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c34);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parsepriority();
                            if (s5 !== peg$FAILED) {
                                s4 = [s4, s5];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                        if (s3 === peg$FAILED) {
                            s3 = peg$c1;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c35(s1, s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parserelation() {
                var s0, s1;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c36) {
                    s1 = peg$c36;
                    peg$currPos += 2;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c37);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c38();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c39) {
                        s1 = peg$c39;
                        peg$currPos += 2;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c40);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c41();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c42) {
                            s1 = peg$c42;
                            peg$currPos += 2;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c43);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c44();
                        }
                        s0 = s1;
                    }
                }
                return s0;
            }
            function peg$parseobjectOfPredicate() {
                var s0;
                s0 = peg$parseconstant();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseviewName();
                }
                return s0;
            }
            function peg$parsepriority() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c45.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c46);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        if (peg$c45.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c46);
                            }
                        }
                    }
                }
                else {
                    s1 = peg$c0;
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c47(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseconstant() {
                var s0, s1;
                s0 = peg$currPos;
                s1 = peg$parsenumber();
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c48(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseviewName() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = [];
                if (peg$c49.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    {
                        peg$fail(peg$c50);
                    }
                }
                if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        if (peg$c49.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s3 = peg$FAILED;
                            {
                                peg$fail(peg$c50);
                            }
                        }
                    }
                }
                else {
                    s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                    s2 = input.substring(s1, peg$currPos);
                }
                s1 = s2;
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = [];
                    if (peg$c51.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        {
                            peg$fail(peg$c52);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (peg$c51.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c52);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s3 = input.substring(s2, peg$currPos);
                    }
                    s2 = s3;
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c53(s1, s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parsenumber() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c45.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c46);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        if (peg$c45.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c46);
                            }
                        }
                    }
                }
                else {
                    s1 = peg$c0;
                }
                if (s1 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                        s2 = peg$c54;
                        peg$currPos++;
                    }
                    else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c55);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        if (peg$c45.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c46);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                if (peg$c45.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                }
                                else {
                                    s4 = peg$FAILED;
                                    {
                                        peg$fail(peg$c46);
                                    }
                                }
                            }
                        }
                        else {
                            s3 = peg$c0;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c56(s1, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    if (peg$c45.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c46);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            if (peg$c45.test(input.charAt(peg$currPos))) {
                                s2 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s2 = peg$FAILED;
                                {
                                    peg$fail(peg$c46);
                                }
                            }
                        }
                    }
                    else {
                        s1 = peg$c0;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c57(s1);
                    }
                    s0 = s1;
                }
                return s0;
            }
            function extend(dst) {
                for (var i = 1; i < arguments.length; i++) {
                    for (var k in arguments[i]) {
                        dst[k] = arguments[i][k];
                    }
                }
                return dst;
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                return peg$result;
            }
            else {
                if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                    peg$fail({ type: "end", description: "end of input" });
                }
                throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
            }
        }
        return {
            SyntaxError: SyntaxError,
            parse: parse
        };
    })();

    var parserExt = (function () {
        /*
         * Generated by PEG.js 0.8.0.
         *
         * http://pegjs.majda.cz/
         */
        function peg$subclass(child, parent) {
            function ctor() { this.constructor = child; }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
        }
        function SyntaxError(message, expected, found, offset, line, column) {
            this.message = message;
            this.expected = expected;
            this.found = found;
            this.offset = offset;
            this.line = line;
            this.column = column;
            this.name = "SyntaxError";
        }
        peg$subclass(SyntaxError, Error);
        function parse(input) {
            var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { visualFormatStringExt: peg$parsevisualFormatStringExt }, peg$startRuleFunction = peg$parsevisualFormatStringExt, peg$c0 = peg$FAILED, peg$c1 = "C:", peg$c2 = { type: "literal", value: "C:", description: "\"C:\"" }, peg$c4 = null, peg$c5 = function (view, attribute, attributes, comments) {
                return {
                    type: 'attribute',
                    view: view.view,
                    attributes: [attribute].concat(attributes)
                };
            }, peg$c6 = function (attr, predicates) { return { attr: attr, predicates: predicates }; }, peg$c7 = ":", peg$c8 = { type: "literal", value: ":", description: "\":\"" }, peg$c9 = function (o, superto, view, views, tosuper, comments) {
                return {
                    type: 'vfl',
                    orientation: o ? o[0] : 'horizontal',
                    cascade: (superto || []).concat(view, [].concat.apply([], views), (tosuper || []))
                };
            }, peg$c10 = "HV", peg$c11 = { type: "literal", value: "HV", description: "\"HV\"" }, peg$c12 = function () { return 'horzvert'; }, peg$c13 = "H", peg$c14 = { type: "literal", value: "H", description: "\"H\"" }, peg$c15 = function () { return 'horizontal'; }, peg$c16 = "V", peg$c17 = { type: "literal", value: "V", description: "\"V\"" }, peg$c18 = function () { return 'vertical'; }, peg$c19 = "Z", peg$c20 = { type: "literal", value: "Z", description: "\"Z\"" }, peg$c21 = function () { return 'zIndex'; }, peg$c22 = " ", peg$c23 = { type: "literal", value: " ", description: "\" \"" }, peg$c24 = "//", peg$c25 = { type: "literal", value: "//", description: "\"//\"" }, peg$c26 = { type: "any", description: "any character" }, peg$c27 = "|", peg$c28 = { type: "literal", value: "|", description: "\"|\"" }, peg$c29 = function () { return { view: null }; }, peg$c30 = "[", peg$c31 = { type: "literal", value: "[", description: "\"[\"" }, peg$c32 = ",", peg$c33 = { type: "literal", value: ",", description: "\",\"" }, peg$c34 = "]", peg$c35 = { type: "literal", value: "]", description: "\"]\"" }, peg$c36 = function (view, views) { return views.length ? [view].concat([].concat.apply([], views)) : view; }, peg$c37 = function (view, predicates, cascadedViews) {
                return extend(extend(view, predicates ? { constraints: predicates } : {}), cascadedViews ? {
                    cascade: cascadedViews
                } : {});
            }, peg$c38 = function (views, connection) { return [].concat([].concat.apply([], views), [connection]); }, peg$c39 = "->", peg$c40 = { type: "literal", value: "->", description: "\"->\"" }, peg$c41 = function () { return [{ relation: 'none' }]; }, peg$c42 = "-", peg$c43 = { type: "literal", value: "-", description: "\"-\"" }, peg$c44 = function (predicateList) { return predicateList; }, peg$c45 = function () { return [{ relation: 'equ', constant: 'default' }]; }, peg$c46 = "~", peg$c47 = { type: "literal", value: "~", description: "\"~\"" }, peg$c48 = function () { return [{ relation: 'equ', equalSpacing: true }]; }, peg$c49 = "", peg$c50 = function () { return [{ relation: 'equ', constant: 0 }]; }, peg$c51 = function (p) { return [{ relation: 'equ', multiplier: p.multiplier }]; }, peg$c52 = function (n) { return [{ relation: 'equ', constant: n }]; }, peg$c53 = "(", peg$c54 = { type: "literal", value: "(", description: "\"(\"" }, peg$c55 = ")", peg$c56 = { type: "literal", value: ")", description: "\")\"" }, peg$c57 = function (p, ps) { return [p].concat(ps.map(function (p) { return p[1]; })); }, peg$c58 = "@", peg$c59 = { type: "literal", value: "@", description: "\"@\"" }, peg$c60 = function (r, o, p) { return extend({ relation: 'equ' }, (r || {}), o, (p ? p[1] : {})); }, peg$c61 = function (r, o, p) { return extend({ relation: 'equ', equalSpacing: true }, (r || {}), o, (p ? p[1] : {})); }, peg$c62 = "==", peg$c63 = { type: "literal", value: "==", description: "\"==\"" }, peg$c64 = function () { return { relation: 'equ' }; }, peg$c65 = "<=", peg$c66 = { type: "literal", value: "<=", description: "\"<=\"" }, peg$c67 = function () { return { relation: 'leq' }; }, peg$c68 = ">=", peg$c69 = { type: "literal", value: ">=", description: "\">=\"" }, peg$c70 = function () { return { relation: 'geq' }; }, peg$c71 = /^[0-9]/, peg$c72 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c73 = function (digits) { return { priority: parseInt(digits.join(""), 10) }; }, peg$c74 = function (n) { return { constant: n }; }, peg$c75 = function (n) { return { constant: -n }; }, peg$c76 = "+", peg$c77 = { type: "literal", value: "+", description: "\"+\"" }, peg$c78 = "%", peg$c79 = { type: "literal", value: "%", description: "\"%\"" }, peg$c80 = function (n) { return { view: null, multiplier: n / 100 }; }, peg$c81 = function (n) { return { view: null, multiplier: n / -100 }; }, peg$c82 = function (vn, a, m, c) { return { view: vn.view, attribute: a ? a : undefined, multiplier: m ? m : 1, constant: c ? c : undefined }; }, peg$c83 = ".left", peg$c84 = { type: "literal", value: ".left", description: "\".left\"" }, peg$c85 = function () { return 'left'; }, peg$c86 = ".right", peg$c87 = { type: "literal", value: ".right", description: "\".right\"" }, peg$c88 = function () { return 'right'; }, peg$c89 = ".top", peg$c90 = { type: "literal", value: ".top", description: "\".top\"" }, peg$c91 = function () { return 'top'; }, peg$c92 = ".bottom", peg$c93 = { type: "literal", value: ".bottom", description: "\".bottom\"" }, peg$c94 = function () { return 'bottom'; }, peg$c95 = ".width", peg$c96 = { type: "literal", value: ".width", description: "\".width\"" }, peg$c97 = function () { return 'width'; }, peg$c98 = ".height", peg$c99 = { type: "literal", value: ".height", description: "\".height\"" }, peg$c100 = function () { return 'height'; }, peg$c101 = ".centerX", peg$c102 = { type: "literal", value: ".centerX", description: "\".centerX\"" }, peg$c103 = function () { return 'centerX'; }, peg$c104 = ".centerY", peg$c105 = { type: "literal", value: ".centerY", description: "\".centerY\"" }, peg$c106 = function () { return 'centerY'; }, peg$c107 = "/", peg$c108 = { type: "literal", value: "/", description: "\"/\"" }, peg$c109 = function (n) { return 1 / n; }, peg$c110 = "/+", peg$c111 = { type: "literal", value: "/+", description: "\"/+\"" }, peg$c112 = "/-", peg$c113 = { type: "literal", value: "/-", description: "\"/-\"" }, peg$c114 = function (n) { return -1 / n; }, peg$c115 = "*", peg$c116 = { type: "literal", value: "*", description: "\"*\"" }, peg$c117 = function (n) { return n; }, peg$c118 = "*+", peg$c119 = { type: "literal", value: "*+", description: "\"*+\"" }, peg$c120 = "*-", peg$c121 = { type: "literal", value: "*-", description: "\"*-\"" }, peg$c122 = function (n) { return -n; }, peg$c123 = /^[a-zA-Z_]/, peg$c124 = { type: "class", value: "[a-zA-Z_]", description: "[a-zA-Z_]" }, peg$c125 = /^[a-zA-Z0-9_]/, peg$c126 = { type: "class", value: "[a-zA-Z0-9_]", description: "[a-zA-Z0-9_]" }, peg$c127 = function (f, v, r) { return { view: f + v, range: r, $parserOffset: offset() }; }, peg$c128 = function (f, v) { return { view: f + v, $parserOffset: offset() }; }, peg$c129 = "..", peg$c130 = { type: "literal", value: "..", description: "\"..\"" }, peg$c131 = function (d) { return parseInt(d); }, peg$c132 = ".", peg$c133 = { type: "literal", value: ".", description: "\".\"" }, peg$c134 = function (digits, decimals) { return parseFloat(digits.concat(".").concat(decimals).join(""), 10); }, peg$c135 = function (digits) { return parseInt(digits.join(""), 10); }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$result;
            if ("startRule" in options) {
                if (!(options.startRule in peg$startRuleFunctions)) {
                    throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                }
                peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
            }
            function offset() {
                return peg$reportedPos;
            }
            function peg$computePosDetails(pos) {
                function advance(details, startPos, endPos) {
                    var p, ch;
                    for (p = startPos; p < endPos; p++) {
                        ch = input.charAt(p);
                        if (ch === "\n") {
                            if (!details.seenCR) {
                                details.line++;
                            }
                            details.column = 1;
                            details.seenCR = false;
                        }
                        else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                            details.line++;
                            details.column = 1;
                            details.seenCR = true;
                        }
                        else {
                            details.column++;
                            details.seenCR = false;
                        }
                    }
                }
                if (peg$cachedPos !== pos) {
                    if (peg$cachedPos > pos) {
                        peg$cachedPos = 0;
                        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
                    }
                    advance(peg$cachedPosDetails, peg$cachedPos, pos);
                    peg$cachedPos = pos;
                }
                return peg$cachedPosDetails;
            }
            function peg$fail(expected) {
                if (peg$currPos < peg$maxFailPos) {
                    return;
                }
                if (peg$currPos > peg$maxFailPos) {
                    peg$maxFailPos = peg$currPos;
                    peg$maxFailExpected = [];
                }
                peg$maxFailExpected.push(expected);
            }
            function peg$buildException(message, expected, pos) {
                function cleanupExpected(expected) {
                    var i = 1;
                    expected.sort(function (a, b) {
                        if (a.description < b.description) {
                            return -1;
                        }
                        else if (a.description > b.description) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    });
                    while (i < expected.length) {
                        if (expected[i - 1] === expected[i]) {
                            expected.splice(i, 1);
                        }
                        else {
                            i++;
                        }
                    }
                }
                function buildMessage(expected, found) {
                    function stringEscape(s) {
                        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
                        return s
                            .replace(/\\/g, '\\\\')
                            .replace(/"/g, '\\"')
                            .replace(/\x08/g, '\\b')
                            .replace(/\t/g, '\\t')
                            .replace(/\n/g, '\\n')
                            .replace(/\f/g, '\\f')
                            .replace(/\r/g, '\\r')
                            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
                            .replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) { return '\\x' + hex(ch); })
                            .replace(/[\u0180-\u0FFF]/g, function (ch) { return '\\u0' + hex(ch); })
                            .replace(/[\u1080-\uFFFF]/g, function (ch) { return '\\u' + hex(ch); });
                    }
                    var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
                    for (i = 0; i < expected.length; i++) {
                        expectedDescs[i] = expected[i].description;
                    }
                    expectedDesc = expected.length > 1
                        ? expectedDescs.slice(0, -1).join(", ")
                            + " or "
                            + expectedDescs[expected.length - 1]
                        : expectedDescs[0];
                    foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
                    return "Expected " + expectedDesc + " but " + foundDesc + " found.";
                }
                var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
                if (expected !== null) {
                    cleanupExpected(expected);
                }
                return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
            }
            function peg$parsevisualFormatStringExt() {
                var s0;
                s0 = peg$parsevisualFormatString();
                if (s0 === peg$FAILED) {
                    s0 = peg$parsevisualFormatStringConstraintExpression();
                }
                return s0;
            }
            function peg$parsevisualFormatStringConstraintExpression() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c1) {
                    s1 = peg$c1;
                    peg$currPos += 2;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c2);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseviewName();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseattributePredicate();
                        if (s3 !== peg$FAILED) {
                            s4 = [];
                            s5 = peg$parseattributePredicate();
                            while (s5 !== peg$FAILED) {
                                s4.push(s5);
                                s5 = peg$parseattributePredicate();
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parsecomments();
                                if (s5 === peg$FAILED) {
                                    s5 = peg$c4;
                                }
                                if (s5 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c5(s2, s3, s4);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseattributePredicate() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = peg$parseattribute();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsepredicateListWithParens();
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c6(s1, s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parsevisualFormatString() {
                var s0, s1, s2, s3, s4, s5, s6, s7;
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = peg$parseorientation();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                        s3 = peg$c7;
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        {
                            peg$fail(peg$c8);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s2 = [s2, s3];
                        s1 = s2;
                    }
                    else {
                        peg$currPos = s1;
                        s1 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$c0;
                }
                if (s1 === peg$FAILED) {
                    s1 = peg$c4;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parsesuperview();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseconnection();
                        if (s4 !== peg$FAILED) {
                            s3 = [s3, s4];
                            s2 = s3;
                        }
                        else {
                            peg$currPos = s2;
                            s2 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$c0;
                    }
                    if (s2 === peg$FAILED) {
                        s2 = peg$c4;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseviewGroup();
                        if (s3 !== peg$FAILED) {
                            s4 = [];
                            s5 = peg$currPos;
                            s6 = peg$parseconnection();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseviewGroup();
                                if (s7 !== peg$FAILED) {
                                    s6 = [s6, s7];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$c0;
                            }
                            while (s5 !== peg$FAILED) {
                                s4.push(s5);
                                s5 = peg$currPos;
                                s6 = peg$parseconnection();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parseviewGroup();
                                    if (s7 !== peg$FAILED) {
                                        s6 = [s6, s7];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$c0;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = peg$currPos;
                                s6 = peg$parseconnection();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parsesuperview();
                                    if (s7 !== peg$FAILED) {
                                        s6 = [s6, s7];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$c0;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$c0;
                                }
                                if (s5 === peg$FAILED) {
                                    s5 = peg$c4;
                                }
                                if (s5 !== peg$FAILED) {
                                    s6 = peg$parsecomments();
                                    if (s6 === peg$FAILED) {
                                        s6 = peg$c4;
                                    }
                                    if (s6 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c9(s1, s2, s3, s4, s5);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseorientation() {
                var s0, s1;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c10) {
                    s1 = peg$c10;
                    peg$currPos += 2;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c11);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c12();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 72) {
                        s1 = peg$c13;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c14);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c15();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 86) {
                            s1 = peg$c16;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c17);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c18();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 90) {
                                s1 = peg$c19;
                                peg$currPos++;
                            }
                            else {
                                s1 = peg$FAILED;
                                {
                                    peg$fail(peg$c20);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c21();
                            }
                            s0 = s1;
                        }
                    }
                }
                return s0;
            }
            function peg$parsecomments() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = [];
                if (input.charCodeAt(peg$currPos) === 32) {
                    s2 = peg$c22;
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c23);
                    }
                }
                while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    if (input.charCodeAt(peg$currPos) === 32) {
                        s2 = peg$c22;
                        peg$currPos++;
                    }
                    else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c23);
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c24) {
                        s2 = peg$c24;
                        peg$currPos += 2;
                    }
                    else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c25);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        if (input.length > peg$currPos) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c26);
                            }
                        }
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            if (input.length > peg$currPos) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c26);
                                }
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            s1 = [s1, s2, s3];
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parsesuperview() {
                var s0, s1;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 124) {
                    s1 = peg$c27;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c28);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c29();
                }
                s0 = s1;
                return s0;
            }
            function peg$parseviewGroup() {
                var s0, s1, s2, s3, s4, s5, s6;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                    s1 = peg$c30;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c31);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseview();
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c32;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            {
                                peg$fail(peg$c33);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseview();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s5 = peg$c32;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                {
                                    peg$fail(peg$c33);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parseview();
                                if (s6 !== peg$FAILED) {
                                    s5 = [s5, s6];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 93) {
                                s4 = peg$c34;
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c35);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c36(s2, s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseview() {
                var s0, s1, s2, s3;
                s0 = peg$currPos;
                s1 = peg$parseviewNameRange();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsepredicateListWithParens();
                    if (s2 === peg$FAILED) {
                        s2 = peg$c4;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parsecascadedViews();
                        if (s3 === peg$FAILED) {
                            s3 = peg$c4;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c37(s1, s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parsecascadedViews() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 58) {
                    s1 = peg$c7;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c8);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$parseconnection();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseviewGroup();
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                    }
                    if (s3 !== peg$FAILED) {
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$parseconnection();
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseviewGroup();
                                if (s5 !== peg$FAILED) {
                                    s4 = [s4, s5];
                                    s3 = s4;
                                }
                                else {
                                    peg$currPos = s3;
                                    s3 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$c0;
                            }
                        }
                    }
                    else {
                        s2 = peg$c0;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseconnection();
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c38(s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseconnection() {
                var s0, s1, s2, s3;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c39) {
                    s1 = peg$c39;
                    peg$currPos += 2;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c40);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c41();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s1 = peg$c42;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c43);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parsepredicateList();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                                s3 = peg$c42;
                                peg$currPos++;
                            }
                            else {
                                s3 = peg$FAILED;
                                {
                                    peg$fail(peg$c43);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c44(s2);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s1 = peg$c42;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c43);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c45();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 126) {
                                s1 = peg$c46;
                                peg$currPos++;
                            }
                            else {
                                s1 = peg$FAILED;
                                {
                                    peg$fail(peg$c47);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parseequalSpacingPredicateList();
                                if (s2 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 126) {
                                        s3 = peg$c46;
                                        peg$currPos++;
                                    }
                                    else {
                                        s3 = peg$FAILED;
                                        {
                                            peg$fail(peg$c47);
                                        }
                                    }
                                    if (s3 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c44(s2);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 126) {
                                    s1 = peg$c46;
                                    peg$currPos++;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    {
                                        peg$fail(peg$c47);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c48();
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$c49;
                                    if (s1 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c50();
                                    }
                                    s0 = s1;
                                }
                            }
                        }
                    }
                }
                return s0;
            }
            function peg$parsepredicateList() {
                var s0;
                s0 = peg$parsesimplePredicate();
                if (s0 === peg$FAILED) {
                    s0 = peg$parsepredicateListWithParens();
                }
                return s0;
            }
            function peg$parsesimplePredicate() {
                var s0, s1;
                s0 = peg$currPos;
                s1 = peg$parsepercentage();
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c51(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsenumber();
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c52(s1);
                    }
                    s0 = s1;
                }
                return s0;
            }
            function peg$parsepredicateListWithParens() {
                var s0, s1, s2, s3, s4, s5, s6;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 40) {
                    s1 = peg$c53;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c54);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsepredicate();
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c32;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            {
                                peg$fail(peg$c33);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsepredicate();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s5 = peg$c32;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                {
                                    peg$fail(peg$c33);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parsepredicate();
                                if (s6 !== peg$FAILED) {
                                    s5 = [s5, s6];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s4 = peg$c55;
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c56);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c57(s2, s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parsepredicate() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                s1 = peg$parserelation();
                if (s1 === peg$FAILED) {
                    s1 = peg$c4;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseobjectOfPredicate();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 64) {
                            s4 = peg$c58;
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c59);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parsepriority();
                            if (s5 !== peg$FAILED) {
                                s4 = [s4, s5];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                        if (s3 === peg$FAILED) {
                            s3 = peg$c4;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c60(s1, s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseequalSpacingPredicateList() {
                var s0, s1, s2, s3, s4, s5, s6;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 40) {
                    s1 = peg$c53;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c54);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseequalSpacingPredicate();
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s5 = peg$c32;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            {
                                peg$fail(peg$c33);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseequalSpacingPredicate();
                            if (s6 !== peg$FAILED) {
                                s5 = [s5, s6];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$c0;
                        }
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s5 = peg$c32;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                {
                                    peg$fail(peg$c33);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parseequalSpacingPredicate();
                                if (s6 !== peg$FAILED) {
                                    s5 = [s5, s6];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$c0;
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s4 = peg$c55;
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c56);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c57(s2, s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseequalSpacingPredicate() {
                var s0, s1, s2, s3, s4, s5;
                s0 = peg$currPos;
                s1 = peg$parserelation();
                if (s1 === peg$FAILED) {
                    s1 = peg$c4;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseobjectOfPredicate();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 64) {
                            s4 = peg$c58;
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c59);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parsepriority();
                            if (s5 !== peg$FAILED) {
                                s4 = [s4, s5];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$c0;
                        }
                        if (s3 === peg$FAILED) {
                            s3 = peg$c4;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c61(s1, s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parserelation() {
                var s0, s1;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c62) {
                    s1 = peg$c62;
                    peg$currPos += 2;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c63);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c64();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c65) {
                        s1 = peg$c65;
                        peg$currPos += 2;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c66);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c67();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c68) {
                            s1 = peg$c68;
                            peg$currPos += 2;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c69);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c70();
                        }
                        s0 = s1;
                    }
                }
                return s0;
            }
            function peg$parseobjectOfPredicate() {
                var s0;
                s0 = peg$parsepercentage();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseconstant();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseviewPredicate();
                    }
                }
                return s0;
            }
            function peg$parsepriority() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c71.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c72);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        if (peg$c71.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c72);
                            }
                        }
                    }
                }
                else {
                    s1 = peg$c0;
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c73(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseconstant() {
                var s0, s1, s2;
                s0 = peg$currPos;
                s1 = peg$parsenumber();
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c74(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s1 = peg$c42;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c43);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parsenumber();
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c75(s2);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 43) {
                            s1 = peg$c76;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c77);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parsenumber();
                            if (s2 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c74(s2);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                }
                return s0;
            }
            function peg$parsepercentage() {
                var s0, s1, s2, s3;
                s0 = peg$currPos;
                s1 = peg$parsenumber();
                if (s1 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 37) {
                        s2 = peg$c78;
                        peg$currPos++;
                    }
                    else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c79);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c80(s1);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s1 = peg$c42;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c43);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parsenumber();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 37) {
                                s3 = peg$c78;
                                peg$currPos++;
                            }
                            else {
                                s3 = peg$FAILED;
                                {
                                    peg$fail(peg$c79);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c81(s2);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 43) {
                            s1 = peg$c76;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c77);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parsenumber();
                            if (s2 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 37) {
                                    s3 = peg$c78;
                                    peg$currPos++;
                                }
                                else {
                                    s3 = peg$FAILED;
                                    {
                                        peg$fail(peg$c79);
                                    }
                                }
                                if (s3 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c80(s2);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                }
                return s0;
            }
            function peg$parseviewPredicate() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = peg$parseviewName();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseattribute();
                    if (s2 === peg$FAILED) {
                        s2 = peg$c4;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parsemultiplier();
                        if (s3 === peg$FAILED) {
                            s3 = peg$c4;
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parseconstantExpr();
                            if (s4 === peg$FAILED) {
                                s4 = peg$c4;
                            }
                            if (s4 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c82(s1, s2, s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parseattribute() {
                var s0, s1;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 5) === peg$c83) {
                    s1 = peg$c83;
                    peg$currPos += 5;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c84);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c85();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c86) {
                        s1 = peg$c86;
                        peg$currPos += 6;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c87);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c88();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 4) === peg$c89) {
                            s1 = peg$c89;
                            peg$currPos += 4;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c90);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c91();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 7) === peg$c92) {
                                s1 = peg$c92;
                                peg$currPos += 7;
                            }
                            else {
                                s1 = peg$FAILED;
                                {
                                    peg$fail(peg$c93);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c94();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.substr(peg$currPos, 6) === peg$c95) {
                                    s1 = peg$c95;
                                    peg$currPos += 6;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    {
                                        peg$fail(peg$c96);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c97();
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.substr(peg$currPos, 7) === peg$c98) {
                                        s1 = peg$c98;
                                        peg$currPos += 7;
                                    }
                                    else {
                                        s1 = peg$FAILED;
                                        {
                                            peg$fail(peg$c99);
                                        }
                                    }
                                    if (s1 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c100();
                                    }
                                    s0 = s1;
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.substr(peg$currPos, 8) === peg$c101) {
                                            s1 = peg$c101;
                                            peg$currPos += 8;
                                        }
                                        else {
                                            s1 = peg$FAILED;
                                            {
                                                peg$fail(peg$c102);
                                            }
                                        }
                                        if (s1 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c103();
                                        }
                                        s0 = s1;
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            if (input.substr(peg$currPos, 8) === peg$c104) {
                                                s1 = peg$c104;
                                                peg$currPos += 8;
                                            }
                                            else {
                                                s1 = peg$FAILED;
                                                {
                                                    peg$fail(peg$c105);
                                                }
                                            }
                                            if (s1 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c106();
                                            }
                                            s0 = s1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return s0;
            }
            function peg$parsemultiplier() {
                var s0, s1, s2;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 47) {
                    s1 = peg$c107;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c108);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsenumber();
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c109(s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c110) {
                        s1 = peg$c110;
                        peg$currPos += 2;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c111);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parsenumber();
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c109(s2);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c112) {
                            s1 = peg$c112;
                            peg$currPos += 2;
                        }
                        else {
                            s1 = peg$FAILED;
                            {
                                peg$fail(peg$c113);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parsenumber();
                            if (s2 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c114(s2);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 42) {
                                s1 = peg$c115;
                                peg$currPos++;
                            }
                            else {
                                s1 = peg$FAILED;
                                {
                                    peg$fail(peg$c116);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parsenumber();
                                if (s2 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c117(s2);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.substr(peg$currPos, 2) === peg$c118) {
                                    s1 = peg$c118;
                                    peg$currPos += 2;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    {
                                        peg$fail(peg$c119);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    s2 = peg$parsenumber();
                                    if (s2 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c117(s2);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                }
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.substr(peg$currPos, 2) === peg$c120) {
                                        s1 = peg$c120;
                                        peg$currPos += 2;
                                    }
                                    else {
                                        s1 = peg$FAILED;
                                        {
                                            peg$fail(peg$c121);
                                        }
                                    }
                                    if (s1 !== peg$FAILED) {
                                        s2 = peg$parsenumber();
                                        if (s2 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c122(s2);
                                            s0 = s1;
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                    }
                                }
                            }
                        }
                    }
                }
                return s0;
            }
            function peg$parseconstantExpr() {
                var s0, s1, s2;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c42;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c43);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parsenumber();
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c122(s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 43) {
                        s1 = peg$c76;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        {
                            peg$fail(peg$c77);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parsenumber();
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c117(s2);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                return s0;
            }
            function peg$parseviewNameRange() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = [];
                if (peg$c123.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    {
                        peg$fail(peg$c124);
                    }
                }
                if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        if (peg$c123.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s3 = peg$FAILED;
                            {
                                peg$fail(peg$c124);
                            }
                        }
                    }
                }
                else {
                    s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                    s2 = input.substring(s1, peg$currPos);
                }
                s1 = s2;
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = [];
                    if (peg$c125.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        {
                            peg$fail(peg$c126);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (peg$c125.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c126);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s3 = input.substring(s2, peg$currPos);
                    }
                    s2 = s3;
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parserange();
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c127(s1, s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    s2 = [];
                    if (peg$c123.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        {
                            peg$fail(peg$c124);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            if (peg$c123.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s3 = peg$FAILED;
                                {
                                    peg$fail(peg$c124);
                                }
                            }
                        }
                    }
                    else {
                        s2 = peg$c0;
                    }
                    if (s2 !== peg$FAILED) {
                        s2 = input.substring(s1, peg$currPos);
                    }
                    s1 = s2;
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        s3 = [];
                        if (peg$c125.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c126);
                            }
                        }
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            if (peg$c125.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s4 = peg$FAILED;
                                {
                                    peg$fail(peg$c126);
                                }
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            s3 = input.substring(s2, peg$currPos);
                        }
                        s2 = s3;
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c128(s1, s2);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                return s0;
            }
            function peg$parseviewName() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = [];
                if (peg$c123.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    {
                        peg$fail(peg$c124);
                    }
                }
                if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        if (peg$c123.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s3 = peg$FAILED;
                            {
                                peg$fail(peg$c124);
                            }
                        }
                    }
                }
                else {
                    s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                    s2 = input.substring(s1, peg$currPos);
                }
                s1 = s2;
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = [];
                    if (peg$c125.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        {
                            peg$fail(peg$c126);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (peg$c125.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c126);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s3 = input.substring(s2, peg$currPos);
                    }
                    s2 = s3;
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c128(s1, s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parserange() {
                var s0, s1, s2, s3;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c129) {
                    s1 = peg$c129;
                    peg$currPos += 2;
                }
                else {
                    s1 = peg$FAILED;
                    {
                        peg$fail(peg$c130);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    if (peg$c71.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        {
                            peg$fail(peg$c72);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            if (peg$c71.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s3 = peg$FAILED;
                                {
                                    peg$fail(peg$c72);
                                }
                            }
                        }
                    }
                    else {
                        s2 = peg$c0;
                    }
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c131(s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                return s0;
            }
            function peg$parsenumber() {
                var s0, s1, s2, s3, s4;
                s0 = peg$currPos;
                s1 = [];
                if (peg$c71.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    {
                        peg$fail(peg$c72);
                    }
                }
                if (s2 !== peg$FAILED) {
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        if (peg$c71.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s2 = peg$FAILED;
                            {
                                peg$fail(peg$c72);
                            }
                        }
                    }
                }
                else {
                    s1 = peg$c0;
                }
                if (s1 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                        s2 = peg$c132;
                        peg$currPos++;
                    }
                    else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c133);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        if (peg$c71.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            {
                                peg$fail(peg$c72);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                if (peg$c71.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                }
                                else {
                                    s4 = peg$FAILED;
                                    {
                                        peg$fail(peg$c72);
                                    }
                                }
                            }
                        }
                        else {
                            s3 = peg$c0;
                        }
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c134(s1, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    if (peg$c71.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s2 = peg$FAILED;
                        {
                            peg$fail(peg$c72);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            if (peg$c71.test(input.charAt(peg$currPos))) {
                                s2 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s2 = peg$FAILED;
                                {
                                    peg$fail(peg$c72);
                                }
                            }
                        }
                    }
                    else {
                        s1 = peg$c0;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c135(s1);
                    }
                    s0 = s1;
                }
                return s0;
            }
            function extend(dst) {
                for (var i = 1; i < arguments.length; i++) {
                    for (var k in arguments[i]) {
                        dst[k] = arguments[i][k];
                    }
                }
                return dst;
            }
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                return peg$result;
            }
            else {
                if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                    peg$fail({ type: "end", description: "end of input" });
                }
                throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
            }
        }
        return {
            SyntaxError: SyntaxError,
            parse: parse
        };
    })();

    const Orientation = {
        HORIZONTAL: 1,
        VERTICAL: 2,
        ZINDEX: 4,
    };
    /**
     * Helper function that inserts equal spacers (~).
     * @private
     */
    function _processEqualSpacer(context, stackView) {
        // Determine unique name for the spacer
        context.equalSpacerIndex = context.equalSpacerIndex || 1;
        const name = '_~' + context.lineIndex + ':' + context.equalSpacerIndex + '~';
        if (context.equalSpacerIndex > 1) {
            // Ensure that all spacers have the same width/height
            context.constraints.push({
                view1: '_~' + context.lineIndex + ':1~',
                attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
                relation: context.relation.relation || Relation.EQU,
                view2: name,
                attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
                priority: context.relation.priority,
            });
        }
        context.equalSpacerIndex++;
        // Enforce view/proportional width/height
        if (context.relation.view || (context.relation.multiplier && context.relation.multiplier !== 1)) {
            context.constraints.push({
                view1: name,
                attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
                relation: context.relation.relation || Relation.EQU,
                view2: context.relation.view,
                attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
                priority: context.relation.priority,
                multiplier: context.relation.multiplier,
            });
            context.relation.multiplier = undefined;
        }
        else if (context.relation.constant) {
            context.constraints.push({
                view1: name,
                attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
                relation: Relation.EQU,
                view2: null,
                attr2: Attribute.CONST,
                priority: context.relation.priority,
                constant: context.relation.constant,
            });
            context.relation.constant = undefined;
        }
        // Add constraint
        for (var i = 0; i < context.prevViews.length; i++) {
            const prevView = context.prevViews[i];
            switch (context.orientation) {
                case Orientation.HORIZONTAL:
                    context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
                    context.curAttr = Attribute.LEFT;
                    break;
                case Orientation.VERTICAL:
                    context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
                    context.curAttr = Attribute.TOP;
                    break;
                case Orientation.ZINDEX:
                    context.prevAttr = Attribute.ZINDEX;
                    context.curAttr = Attribute.ZINDEX;
                    context.relation.constant = prevView !== stackView ? 'default' : 0;
                    break;
            }
            context.constraints.push({
                view1: prevView,
                attr1: context.prevAttr,
                relation: context.relation.relation,
                view2: name,
                attr2: context.curAttr,
                priority: context.relation.priority,
            });
        }
        context.prevViews = [name];
    }
    /**
     * Helper function that inserts proportional spacers (-12%-).
     * @private
     */
    function _processProportionalSpacer(context, stackView) {
        context.proportionalSpacerIndex = context.proportionalSpacerIndex || 1;
        const name = '_-' + context.lineIndex + ':' + context.proportionalSpacerIndex + '-';
        context.proportionalSpacerIndex++;
        context.constraints.push({
            view1: name,
            attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
            relation: context.relation.relation || Relation.EQU,
            view2: context.relation.view,
            attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
            priority: context.relation.priority,
            multiplier: context.relation.multiplier,
        });
        context.relation.multiplier = undefined;
        // Add constraint
        for (var i = 0; i < context.prevViews.length; i++) {
            const prevView = context.prevViews[i];
            switch (context.orientation) {
                case Orientation.HORIZONTAL:
                    context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
                    context.curAttr = Attribute.LEFT;
                    break;
                case Orientation.VERTICAL:
                    context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
                    context.curAttr = Attribute.TOP;
                    break;
                case Orientation.ZINDEX:
                    context.prevAttr = Attribute.ZINDEX;
                    context.curAttr = Attribute.ZINDEX;
                    context.relation.constant = prevView !== stackView ? 'default' : 0;
                    break;
            }
            context.constraints.push({
                view1: prevView,
                attr1: context.prevAttr,
                relation: context.relation.relation,
                view2: name,
                attr2: context.curAttr,
                priority: context.relation.priority,
            });
        }
        context.prevViews = [name];
    }
    /**
     * In case of a stack-view, set constraints for opposite orientations
     * @private
     */
    function _processStackView(context, name, subView) {
        let viewName;
        for (var orientation = 1; orientation <= 4; orientation *= 2) {
            if (subView.orientations & orientation &&
                subView.stack.orientation !== orientation &&
                !(subView.stack.processedOrientations & orientation)) {
                subView.stack.processedOrientations = subView.stack.processedOrientations | orientation;
                viewName = viewName || {
                    name: name,
                    type: 'stack',
                };
                for (var i = 0, j = subView.stack.subViews.length; i < j; i++) {
                    if (orientation === Orientation.ZINDEX) {
                        context.constraints.push({
                            view1: viewName,
                            attr1: Attribute.ZINDEX,
                            relation: Relation.EQU,
                            view2: subView.stack.subViews[i],
                            attr2: Attribute.ZINDEX,
                        });
                    }
                    else {
                        context.constraints.push({
                            view1: viewName,
                            attr1: orientation === Orientation.VERTICAL ? Attribute.HEIGHT : Attribute.WIDTH,
                            relation: Relation.EQU,
                            view2: subView.stack.subViews[i],
                            attr2: orientation === Orientation.VERTICAL ? Attribute.HEIGHT : Attribute.WIDTH,
                        });
                        context.constraints.push({
                            view1: viewName,
                            attr1: orientation === Orientation.VERTICAL ? Attribute.TOP : Attribute.LEFT,
                            relation: Relation.EQU,
                            view2: subView.stack.subViews[i],
                            attr2: orientation === Orientation.VERTICAL ? Attribute.TOP : Attribute.LEFT,
                        });
                    }
                }
            }
        }
    }
    /**
     * Recursive helper function converts a view-name and a range to a series
     * of view-names (e.g. [child1, child2, child3, ...]).
     * @private
     */
    function _getRange(name, range) {
        if (range === true) {
            range = name.match(/\.\.\d+$/);
            if (range) {
                name = name.substring(0, name.length - range[0].length);
                range = parseInt(range[0].substring(2));
            }
        }
        if (!range) {
            return [name];
        }
        var start = name.match(/\d+$/);
        var res = [];
        var i;
        if (start) {
            name = name.substring(0, name.length - start[0].length);
            // FIXME
            // @ts-expect-error what the heck is being passed into parseInt here?
            for (i = parseInt(start); i <= range; i++) {
                res.push(name + i);
            }
        }
        else {
            res.push(name);
            for (i = 2; i <= range; i++) {
                res.push(name + i);
            }
        }
        return res;
    }
    /**
     * Recursive helper function that processes the cascaded data.
     * @private
     */
    function _processCascade(context, cascade, parentItem) {
        const stackView = parentItem ? parentItem.view : null;
        const subViews = [];
        let curViews = [];
        let subView;
        if (stackView) {
            cascade.push({ view: stackView });
            curViews.push(stackView);
        }
        for (var i = 0; i < cascade.length; i++) {
            let item = cascade[i];
            if ((!Array.isArray(item) && item.hasOwnProperty('view')) ||
                (Array.isArray(item) && item[0].view && !item[0].relation)) {
                const items = Array.isArray(item) ? item : [item];
                for (var z = 0; z < items.length; z++) {
                    item = items[z];
                    const viewRange = item === ',' ? [] : item.view ? _getRange(item.view, item.range) : [null];
                    for (var r = 0; r < viewRange.length; r++) {
                        const curView = viewRange[r];
                        curViews.push(curView);
                        //
                        // Add this view to the collection of subViews
                        //
                        if (curView !== stackView) {
                            subViews.push(curView);
                            // FIXME
                            // @ts-expect-error
                            subView = context.subViews[curView];
                            if (!subView) {
                                subView = { orientations: 0 };
                                // FIXME
                                // @ts-expect-error
                                context.subViews[curView] = subView;
                            }
                            subView.orientations = subView.orientations | context.orientation;
                            if (subView.stack) {
                                _processStackView(context, curView, subView);
                            }
                        }
                        //
                        // Process the relationship between this and the previous views
                        //
                        if (context.prevViews !== undefined && curView !== undefined && context.relation) {
                            if (context.relation.relation !== 'none') {
                                for (var p = 0; p < context.prevViews.length; p++) {
                                    const prevView = context.prevViews[p];
                                    switch (context.orientation) {
                                        case Orientation.HORIZONTAL:
                                            context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
                                            context.curAttr = curView !== stackView ? Attribute.LEFT : Attribute.RIGHT;
                                            break;
                                        case Orientation.VERTICAL:
                                            context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
                                            context.curAttr = curView !== stackView ? Attribute.TOP : Attribute.BOTTOM;
                                            break;
                                        case Orientation.ZINDEX:
                                            context.prevAttr = Attribute.ZINDEX;
                                            context.curAttr = Attribute.ZINDEX;
                                            context.relation.constant = !prevView
                                                ? 0
                                                : context.relation.constant || 'default';
                                            break;
                                    }
                                    context.constraints.push({
                                        view1: prevView,
                                        attr1: context.prevAttr,
                                        relation: context.relation.relation,
                                        view2: curView,
                                        attr2: context.curAttr,
                                        multiplier: context.relation.multiplier,
                                        constant: context.relation.constant === 'default' || !context.relation.constant
                                            ? context.relation.constant
                                            : -context.relation.constant,
                                        priority: context.relation.priority,
                                    });
                                }
                            }
                        }
                        //
                        // Process view size constraints
                        //
                        const constraints = item.constraints;
                        if (constraints) {
                            for (var n = 0; n < constraints.length; n++) {
                                context.prevAttr = context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT;
                                context.curAttr =
                                    constraints[n].view || constraints[n].multiplier
                                        ? constraints[n].attribute || context.prevAttr
                                        : constraints[n].variable
                                            ? Attribute.VARIABLE
                                            : Attribute.CONST;
                                context.constraints.push({
                                    view1: curView,
                                    attr1: context.prevAttr,
                                    relation: constraints[n].relation,
                                    view2: constraints[n].view,
                                    attr2: context.curAttr,
                                    multiplier: constraints[n].multiplier,
                                    constant: constraints[n].constant,
                                    priority: constraints[n].priority,
                                });
                            }
                        }
                        //
                        // Process cascaded data (child stack-views)
                        //
                        if (item.cascade) {
                            _processCascade(context, item.cascade, item);
                        }
                    }
                }
            }
            else if (item !== ',') {
                context.prevViews = curViews;
                curViews = [];
                context.relation = item[0];
                if (context.prevViews !== undefined) {
                    if (context.relation.equalSpacing) {
                        _processEqualSpacer(context, stackView);
                    }
                    if (context.relation.multiplier) {
                        _processProportionalSpacer(context, stackView);
                    }
                }
            }
        }
        if (stackView) {
            subView = context.subViews[stackView];
            if (!subView) {
                subView = { orientations: context.orientation };
                context.subViews[stackView] = subView;
            }
            else if (subView.stack) {
                const err = new Error('A stack named "' + stackView + '" has already been created');
                // FIXME
                // @ts-expect-error
                err.column = parentItem.$parserOffset + 1;
                throw err;
            }
            subView.stack = {
                orientation: context.orientation,
                processedOrientations: context.orientation,
                subViews: subViews,
            };
            _processStackView(context, stackView, subView);
        }
    }
    const metaInfoCategories = ['viewport', 'spacing', 'colors', 'shapes', 'widths', 'heights'];
    /**
     * VisualFormat
     *
     * @namespace VisualFormat
     */
    class VisualFormat {
        /**
         * Parses a single line of vfl into an array of constraint definitions.
         *
         * When the visual-format could not be succesfully parsed an exception is thrown containing
         * additional info about the parse error and column position.
         *
         * @param {String} visualFormat Visual format string (cannot contain line-endings!).
         * @param {Object} [options] Configuration options.
         * @param {Boolean} [options.extended] When set to true uses the extended syntax (default: false).
         * @param {String} [options.outFormat] Output format (`constraints` or `raw`) (default: `constraints`).
         * @param {Number} [options.lineIndex] Line-index used when auto generating equal-spacing constraints.
         * @return {Array} Array of constraint definitions.
         */
        static parseLine(visualFormat, options) {
            if (visualFormat.length === 0 || (options && options.extended && visualFormat.indexOf('//') === 0)) {
                return [];
            }
            const res = options && options.extended ? parserExt.parse(visualFormat) : parser.parse(visualFormat);
            if (options && options.outFormat === 'raw') {
                return [res];
            }
            let context = {
                constraints: [],
                lineIndex: (options ? options.lineIndex : undefined) || 1,
                subViews: (options ? options.subViews : undefined) || {},
            };
            if (res.type === 'attribute') {
                for (let n = 0; n < res.attributes.length; n++) {
                    const attr = res.attributes[n];
                    for (let m = 0; m < attr.predicates.length; m++) {
                        const predicate = attr.predicates[m];
                        context.constraints.push({
                            view1: res.view,
                            attr1: attr.attr,
                            relation: predicate.relation,
                            view2: predicate.view,
                            attr2: predicate.attribute || attr.attr,
                            multiplier: predicate.multiplier,
                            constant: predicate.constant,
                            priority: predicate.priority,
                        });
                    }
                }
            }
            else {
                switch (res.orientation) {
                    case 'horizontal':
                        context.orientation = Orientation.HORIZONTAL;
                        context.horizontal = true;
                        _processCascade(context, res.cascade, null);
                        break;
                    case 'vertical':
                        context.orientation = Orientation.VERTICAL;
                        _processCascade(context, res.cascade, null);
                        break;
                    case 'horzvert':
                        context.orientation = Orientation.HORIZONTAL;
                        context.horizontal = true;
                        _processCascade(context, res.cascade, null);
                        context = {
                            constraints: context.constraints,
                            lineIndex: context.lineIndex,
                            subViews: context.subViews,
                            orientation: Orientation.VERTICAL,
                        };
                        _processCascade(context, res.cascade, null);
                        break;
                    case 'zIndex':
                        context.orientation = Orientation.ZINDEX;
                        _processCascade(context, res.cascade, null);
                        break;
                }
            }
            return context.constraints;
        }
        /**
         * Parses one or more visual format strings into an array of constraint definitions.
         *
         * When the visual-format could not be succesfully parsed an exception is thrown containing
         * additional info about the parse error and column position.
         *
         * @param {String|Array} visualFormat One or more visual format strings.
         * @param {Object} [options] Configuration options.
         * @param {Boolean} [options.extended] When set to true uses the extended syntax (default: false).
         * @param {Boolean} [options.strict] When set to false trims any leading/trailing spaces and ignores empty lines (default: true).
         * @param {String} [options.lineSeparator] String that defines the end of a line (default `\n`).
         * @param {String} [options.outFormat] Output format (`constraints` or `raw`) (default: `constraints`).
         * @return {Array} Array of constraint definitions.
         */
        static parse(visualFormat, options) {
            const lineSeparator = options && options.lineSeparator ? options.lineSeparator : '\n';
            if (!Array.isArray(visualFormat) && visualFormat.indexOf(lineSeparator) < 0) {
                try {
                    return this.parseLine(visualFormat, options);
                }
                catch (err) {
                    // @ts-ignore
                    err.source = visualFormat;
                    throw err;
                }
            }
            // Decompose visual-format into an array of strings, and within those strings
            // search for line-endings, and treat each line as a seperate visual-format.
            visualFormat = Array.isArray(visualFormat) ? visualFormat : [visualFormat];
            let lines;
            let constraints = [];
            let lineIndex = 0;
            let line;
            const parseOptions = {
                lineIndex: lineIndex,
                extended: options && options.extended,
                strict: options && options.strict !== undefined ? options.strict : true,
                outFormat: options ? options.outFormat : undefined,
                subViews: {},
            };
            try {
                for (var i = 0; i < visualFormat.length; i++) {
                    lines = visualFormat[i].split(lineSeparator);
                    for (var j = 0; j < lines.length; j++) {
                        line = lines[j];
                        lineIndex++;
                        parseOptions.lineIndex = lineIndex;
                        if (!parseOptions.strict) {
                            line = line.trim();
                        }
                        if (parseOptions.strict || line.length) {
                            constraints = constraints.concat(this.parseLine(line, parseOptions));
                        }
                    }
                }
            }
            catch (err) {
                // @ts-ignore
                err.source = line;
                // @ts-ignore
                err.line = lineIndex;
                throw err;
            }
            return constraints;
        }
        /**
         * Parses meta information from the comments in the VFL.
         *
         * Additional meta information can be specified in the comments
         * for previewing and rendering purposes. For instance, the view-port
         * aspect-ratio, sub-view widths and colors, can be specified. The
         * following example renders three colored circles in the visual-format editor:
         *
         * ```vfl
         * //viewport aspect-ratio:3/1 max-height:300
         * //colors red:#FF0000 green:#00FF00 blue:#0000FF
         * //shapes red:circle green:circle blue:circle
         * H:|-[row:[red(green,blue)]-[green]-[blue]]-|
         * V:|[row]|
         * ```
         *
         * Supported categories and properties:
         *
         * |Category|Property|Example|
         * |--------|--------|-------|
         * |`viewport`|`aspect-ratio:{width}/{height}`|`//viewport aspect-ratio:16/9`|
         * ||`width:[{number}/intrinsic]`|`//viewport width:10`|
         * ||`height:[{number}/intrinsic]`|`//viewport height:intrinsic`|
         * ||`min-width:{number}`|
         * ||`max-width:{number}`|
         * ||`min-height:{number}`|
         * ||`max-height:{number}`|
         * |`spacing`|`[{number}/array]`|`//spacing:8` or `//spacing:[10, 20, 5]`|
         * |`widths`|`{view-name}:[{number}/intrinsic]`|`//widths subview1:100`|
         * |`heights`|`{view-name}:[{number}/intrinsic]`|`//heights subview1:intrinsic`|
         * |`colors`|`{view-name}:{color}`|`//colors redview:#FF0000 blueview:#00FF00`|
         * |`shapes`|`{view-name}:[circle/square]`|`//shapes avatar:circle`|
         *
         * @param {String|Array} visualFormat One or more visual format strings.
         * @param {Object} [options] Configuration options.
         * @param {String} [options.lineSeparator] String that defines the end of a line (default `\n`).
         * @param {String} [options.prefix] When specified, also processes the categories using that prefix (e.g. "-dev-viewport max-height:10").
         * @return {Object} meta-info
         */
        static parseMetaInfo(visualFormat, options) {
            const lineSeparator = options && options.lineSeparator ? options.lineSeparator : '\n';
            const prefix = options ? options.prefix : undefined;
            visualFormat = Array.isArray(visualFormat) ? visualFormat : [visualFormat];
            const metaInfo = {};
            var key;
            for (var k = 0; k < visualFormat.length; k++) {
                const lines = visualFormat[k].split(lineSeparator);
                for (var i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    for (var c = 0; c < metaInfoCategories.length; c++) {
                        for (var s = 0; s < (prefix ? 2 : 1); s++) {
                            const category = metaInfoCategories[c];
                            const prefixedCategory = (s === 0 ? '' : prefix) + category;
                            if (line.indexOf('//' + prefixedCategory + ' ') === 0) {
                                const items = line.substring(3 + prefixedCategory.length).split(' ');
                                for (var j = 0; j < items.length; j++) {
                                    metaInfo[category] = metaInfo[category] || {};
                                    const item = items[j].split(':');
                                    const names = _getRange(item[0], true);
                                    for (var r = 0; r < names.length; r++) {
                                        metaInfo[category][names[r]] = item.length > 1 ? item[1] : '';
                                    }
                                }
                            }
                            else if (line.indexOf('//' + prefixedCategory + ':') === 0) {
                                metaInfo[category] = line.substring(3 + prefixedCategory.length);
                            }
                        }
                    }
                }
            }
            if (metaInfo.viewport) {
                const viewport = metaInfo.viewport;
                var aspectRatio = viewport['aspect-ratio'];
                if (aspectRatio) {
                    aspectRatio = aspectRatio.split('/');
                    viewport['aspect-ratio'] = parseInt(aspectRatio[0]) / parseInt(aspectRatio[1]);
                }
                if (viewport.height !== undefined) {
                    viewport.height = viewport.height === 'intrinsic' ? true : parseInt(viewport.height);
                }
                if (viewport.width !== undefined) {
                    viewport.width = viewport.width === 'intrinsic' ? true : parseInt(viewport.width);
                }
                if (viewport['max-height'] !== undefined) {
                    viewport['max-height'] = parseInt(viewport['max-height']);
                }
                if (viewport['max-width'] !== undefined) {
                    viewport['max-width'] = parseInt(viewport['max-width']);
                }
                if (viewport['min-height'] !== undefined) {
                    viewport['min-height'] = parseInt(viewport['min-height']);
                }
                if (viewport['min-width'] !== undefined) {
                    viewport['min-width'] = parseInt(viewport['min-width']);
                }
            }
            if (metaInfo.widths) {
                for (key in metaInfo.widths) {
                    const width = metaInfo.widths[key] === 'intrinsic' ? true : parseInt(metaInfo.widths[key]);
                    metaInfo.widths[key] = width;
                    // FIXME
                    // @ts-expect-error
                    if (width === undefined || isNaN(width)) {
                        delete metaInfo.widths[key];
                    }
                }
            }
            if (metaInfo.heights) {
                for (key in metaInfo.heights) {
                    const height = metaInfo.heights[key] === 'intrinsic' ? true : parseInt(metaInfo.heights[key]);
                    metaInfo.heights[key] = height;
                    // FIXME
                    // @ts-expect-error
                    if (height === undefined || isNaN(height)) {
                        delete metaInfo.heights[key];
                    }
                }
            }
            if (metaInfo.spacing) {
                const value = JSON.parse(metaInfo.spacing);
                metaInfo.spacing = value;
                if (Array.isArray(value)) {
                    for (var sIdx = 0, len = value.length; sIdx < len; sIdx++) {
                        if (isNaN(value[sIdx])) {
                            delete metaInfo.spacing;
                            break;
                        }
                    }
                }
                else if (value === undefined || isNaN(value)) {
                    delete metaInfo.spacing;
                }
            }
            return metaInfo;
        }
    }

    /**
     * A SubView is automatically generated when constraints are added to a View.
     *
     * @namespace SubView
     */
    class SubView {
        constructor(options) {
            this._name = options.name;
            this._type = options.type;
            this._solver = options.solver;
            this._attr = {};
            if (!options.name) {
                this._attr[Attribute.LEFT] = new kiwi.Variable();
                this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.LEFT], kiwi.Operator.Eq, 0));
                this._attr[Attribute.TOP] = new kiwi.Variable();
                this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.TOP], kiwi.Operator.Eq, 0));
                this._attr[Attribute.ZINDEX] = new kiwi.Variable();
                this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.ZINDEX], kiwi.Operator.Eq, 0));
            }
        }
        toJSON() {
            return {
                name: this.name,
                left: this.left,
                top: this.top,
                width: this.width,
                height: this.height,
            };
        }
        toString() {
            JSON.stringify(this.toJSON(), undefined, 2);
        }
        /**
         * Name of the sub-view.
         * @readonly
         * @type {String}
         */
        get name() {
            return this._name;
        }
        /**
         * Left value (`Attribute.LEFT`).
         * @readonly
         * @type {Number}
         */
        get left() {
            return this._getAttrValue(Attribute.LEFT);
        }
        /**
         * Right value (`Attribute.RIGHT`).
         * @readonly
         * @type {Number}
         */
        get right() {
            return this._getAttrValue(Attribute.RIGHT);
        }
        /**
         * Width value (`Attribute.WIDTH`).
         * @type {Number}
         */
        get width() {
            return this._getAttrValue(Attribute.WIDTH);
        }
        /**
         * Height value (`Attribute.HEIGHT`).
         * @readonly
         * @type {Number}
         */
        get height() {
            return this._getAttrValue(Attribute.HEIGHT);
        }
        /**
         * Intrinsic width of the sub-view.
         *
         * Use this property to explicitely set the width of the sub-view, e.g.:
         * ```javascript
         * var view = new AutoLayout.View(AutoLayout.VisualFormat.parse('|[child1][child2]|'), {
         *   width: 500
         * });
         * view.subViews.child1.intrinsicWidth = 100;
         * console.log('child2 width: ' + view.subViews.child2.width); // 400
         * ```
         *
         * @type {Number}
         */
        get intrinsicWidth() {
            return this._intrinsicWidth;
        }
        set intrinsicWidth(value) {
            if (value !== undefined && value !== this._intrinsicWidth) {
                const attr = this._getAttr(Attribute.WIDTH);
                if (this._intrinsicWidth === undefined) {
                    this._solver.addEditVariable(attr, kiwi.Strength.create(this._name ? 998 : 999, 1000, 1000));
                }
                this._intrinsicWidth = value;
                this._solver.suggestValue(attr, value);
                this._solver.updateVariables();
            }
        }
        /**
         * Intrinsic height of the sub-view.
         *
         * See `intrinsicWidth`.
         *
         * @type {Number}
         */
        get intrinsicHeight() {
            return this._intrinsicHeight;
        }
        set intrinsicHeight(value) {
            if (value !== undefined && value !== this._intrinsicHeight) {
                const attr = this._getAttr(Attribute.HEIGHT);
                if (this._intrinsicHeight === undefined) {
                    this._solver.addEditVariable(attr, kiwi.Strength.create(this._name ? 998 : 999, 1000, 1000));
                }
                this._intrinsicHeight = value;
                this._solver.suggestValue(attr, value);
                this._solver.updateVariables();
            }
        }
        /**
         * Top value (`Attribute.TOP`).
         * @readonly
         * @type {Number}
         */
        get top() {
            return this._getAttrValue(Attribute.TOP);
        }
        /**
         * Bottom value (`Attribute.BOTTOM`).
         * @readonly
         * @type {Number}
         */
        get bottom() {
            return this._getAttrValue(Attribute.BOTTOM);
        }
        /**
         * Horizontal center (`Attribute.CENTERX`).
         * @readonly
         * @type {Number}
         */
        get centerX() {
            return this._getAttrValue(Attribute.CENTERX);
        }
        /**
         * Vertical center (`Attribute.CENTERY`).
         * @readonly
         * @type {Number}
         */
        get centerY() {
            return this._getAttrValue(Attribute.CENTERY);
        }
        /**
         * Z-index (`Attribute.ZINDEX`).
         * @readonly
         * @type {Number}
         */
        get zIndex() {
            return this._getAttrValue(Attribute.ZINDEX);
        }
        /**
         * Returns the type of the sub-view.
         * @readonly
         * @type {String}
         */
        get type() {
            return this._type;
        }
        /**
         * Gets the value of one of the attributes.
         *
         * @param {String|Attribute} attr Attribute name (e.g. 'right', 'centerY', Attribute.TOP).
         * @return {Number} value or `undefined`
         */
        getValue(attr) {
            return this._attr[attr] ? this._attr[attr].value() : undefined;
        }
        /**
         * @private
         */
        _getAttr(attr) {
            if (this._attr[attr]) {
                return this._attr[attr];
            }
            this._attr[attr] = new kiwi.Variable();
            switch (attr) {
                case Attribute.RIGHT:
                    this._getAttr(Attribute.LEFT);
                    this._getAttr(Attribute.WIDTH);
                    this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.LEFT].plus(this._attr[Attribute.WIDTH])));
                    break;
                case Attribute.BOTTOM:
                    this._getAttr(Attribute.TOP);
                    this._getAttr(Attribute.HEIGHT);
                    this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.TOP].plus(this._attr[Attribute.HEIGHT])));
                    break;
                case Attribute.CENTERX:
                    this._getAttr(Attribute.LEFT);
                    this._getAttr(Attribute.WIDTH);
                    this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.LEFT].plus(this._attr[Attribute.WIDTH].divide(2))));
                    break;
                case Attribute.CENTERY:
                    this._getAttr(Attribute.TOP);
                    this._getAttr(Attribute.HEIGHT);
                    this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.TOP].plus(this._attr[Attribute.HEIGHT].divide(2))));
                    break;
            }
            this._solver.updateVariables();
            return this._attr[attr];
        }
        /**
         * @private
         */
        _getAttrValue(attr) {
            return this._getAttr(attr).value();
        }
    }

    const defaultPriorityStrength = kiwi.Strength.create(0, 1000, 1000);
    /**
     * AutoLayout API reference.
     *
     * ### Index
     *
     * |Entity|Type|Description|
     * |---|---|---|
     * |[AutoLayout](#autolayout)|`namespace`|Top level AutoLayout object.|
     * |[VisualFormat](#autolayoutvisualformat--object)|`namespace`|Parses VFL into constraints.|
     * |[View](#autolayoutview)|`class`|Main entity for adding & evaluating constraints.|
     * |[SubView](#autolayoutsubview--object)|`class`|SubView's are automatically created when constraints are added to views. They give access to the evaluated results.|
     * |[Attribute](#autolayoutattribute--enum)|`enum`|Attribute types that are supported when adding constraints.|
     * |[Relation](#autolayoutrelation--enum)|`enum`|Relationship types that are supported when adding constraints.|
     * |[Priority](#autolayoutpriority--enum)|`enum`|Default priority values for when adding constraints.|
     *
     * ### AutoLayout
     *
     * @module AutoLayout
     */
    class View {
        /**
         * @class View
         * @param {Object} [options] Configuration options.
         * @param {Number} [options.width] Initial width of the view.
         * @param {Number} [options.height] Initial height of the view.
         * @param {Number|Object} [options.spacing] Spacing for the view (default: 8) (see `setSpacing`).
         * @param {Array} [options.constraints] One or more constraint definitions (see `addConstraints`).
         */
        constructor(options) {
            this._solver = new kiwi.Solver();
            this._subViews = {};
            this._parentSubView = new SubView({
                solver: this._solver,
            });
            this.setSpacing(options && options.spacing !== undefined ? options.spacing : 8);
            //this.constraints = [];
            if (options) {
                if (options.width !== undefined || options.height !== undefined) {
                    this.setSize(options.width, options.height);
                }
                if (options.constraints) {
                    this.addConstraints(options.constraints);
                }
            }
        }
        /**
         * Sets the width and height of the view.
         *
         * @param {Number} width Width of the view.
         * @param {Number} height Height of the view.
         * @return {View} this
         */
        setSize(width, height /*, depth*/) {
            this._parentSubView.intrinsicWidth = width;
            this._parentSubView.intrinsicHeight = height;
            return this;
        }
        /**
         * Width that was set using `setSize`.
         * @readonly
         * @type {Number}
         */
        get width() {
            return this._parentSubView.intrinsicWidth;
        }
        /**
         * Height that was set using `setSize`.
         * @readonly
         * @type {Number}
         */
        get height() {
            return this._parentSubView.intrinsicHeight;
        }
        /**
         * Width that is calculated from the constraints and the `.intrinsicWidth` of
         * the sub-views.
         *
         * When the width has been explicitely set using `setSize`, the fittingWidth
         * will **always** be the same as the explicitely set width. To calculate the size
         * based on the content, use:
         * ```javascript
         * var view = new AutoLayout.View({
         *   constraints: VisualFormat.parse('|-[view1]-[view2]-'),
         *   spacing: 20
         * });
         * view.subViews.view1.intrinsicWidth = 100;
         * view.subViews.view2.intrinsicWidth = 100;
         * console.log('fittingWidth: ' + view.fittingWidth); // 260
         * ```
         *
         * @readonly
         * @type {Number}
         */
        get fittingWidth() {
            return this._parentSubView.width;
        }
        /**
         * Height that is calculated from the constraints and the `.intrinsicHeight` of
         * the sub-views.
         *
         * See `.fittingWidth`.
         *
         * @readonly
         * @type {Number}
         */
        get fittingHeight() {
            return this._parentSubView.height;
        }
        /**
         * Sets the spacing for the view.
         *
         * The spacing can be set for 7 different variables:
         * `top`, `right`, `bottom`, `left`, `width`, `height` and `zIndex`. The `left`-spacing is
         * used when a spacer is used between the parent-view and a sub-view (e.g. `|-[subView]`).
         * The same is true for the `right`, `top` and `bottom` spacers. The `width` and `height` are
         * used for spacers in between sub-views (e.g. `[view1]-[view2]`).
         *
         * Instead of using the full spacing syntax, it is also possible to use shorthand notations:
         *
         * |Syntax|Type|Description|
         * |---|---|---|
         * |`[top, right, bottom, left, width, height, zIndex]`|Array(7)|Full syntax including z-index **(clockwise order)**.|
         * |`[top, right, bottom, left, width, height]`|Array(6)|Full horizontal & vertical spacing syntax (no z-index) **(clockwise order)**.|
         * |`[horizontal, vertical, zIndex]`|Array(3)|Horizontal = left, right, width, vertical = top, bottom, height.|
         * |`[horizontal, vertical]`|Array(2)|Horizontal = left, right, width, vertical = top, bottom, height, z-index = 1.|
         * |`spacing`|Number|Horizontal & vertical spacing are all the same, z-index = 1.|
         *
         * Examples:
         * ```javascript
         * view.setSpacing(10); // horizontal & vertical spacing 10
         * view.setSpacing([10, 15, 2]); // horizontal spacing 10, vertical spacing 15, z-axis spacing 2
         * view.setSpacing([10, 20, 10, 20, 5, 5]); // top, right, bottom, left, horizontal, vertical
         * view.setSpacing([10, 20, 10, 20, 5, 5, 1]); // top, right, bottom, left, horizontal, vertical, z
         * ```
         *
         * @param {Number|Array} spacing
         * @return {View} this
         */
        setSpacing(spacing) {
            if (!Array.isArray(spacing)) {
                spacing = [spacing, spacing, spacing, spacing, spacing, spacing, 1];
            }
            else {
                // normalize spacing into array: [top, right, bottom, left, horz, vert, z-index]
                switch (spacing.length) {
                    case 1:
                        spacing = [spacing[0], spacing[0], spacing[0], spacing[0], spacing[0], spacing[0], 1];
                        break;
                    case 2:
                        spacing = [spacing[1], spacing[0], spacing[1], spacing[0], spacing[0], spacing[1], 1];
                        break;
                    case 3:
                        spacing = [spacing[1], spacing[0], spacing[1], spacing[0], spacing[0], spacing[1], spacing[2]];
                        break;
                    case 6:
                        spacing = [spacing[0], spacing[1], spacing[2], spacing[3], spacing[4], spacing[5], 1];
                        break;
                    case 7:
                        break;
                    default:
                        throw 'Invalid spacing syntax';
                }
            }
            if (!this._compareSpacing(this._spacing, spacing)) {
                this._spacing = spacing;
                // update spacing variables
                if (this._spacingVars) {
                    for (var i = 0; i < this._spacingVars.length; i++) {
                        if (this._spacingVars[i]) {
                            this._solver.suggestValue(this._spacingVars[i], this._spacing[i]);
                        }
                    }
                    this._solver.updateVariables();
                }
            }
            return this;
        }
        _compareSpacing(old, newz) {
            if (old === newz) {
                return true;
            }
            if (!old || !newz) {
                return false;
            }
            for (var i = 0; i < 7; i++) {
                if (old[i] !== newz[i]) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Adds a constraint definition.
         *
         * A constraint definition has the following format:
         *
         * ```javascript
         * constraint: {
         *   view1: {String},
         *   attr1: {AutoLayout.Attribute},
         *   relation: {AutoLayout.Relation},
         *   view2: {String},
         *   attr2: {AutoLayout.Attribute},
         *   multiplier: {Number},
         *   constant: {Number},
         *   priority: {Number}(0..1000)
         * }
         * ```
         * @param {Object} constraint Constraint definition.
         * @return {View} this
         */
        addConstraint(constraint) {
            this._addConstraint(constraint);
            this._solver.updateVariables();
            return this;
        }
        /**
         * Adds one or more constraint definitions.
         *
         * A constraint definition has the following format:
         *
         * ```javascript
         * constraint: {
         *   view1: {String},
         *   attr1: {AutoLayout.Attribute},
         *   relation: {AutoLayout.Relation},
         *   view2: {String},
         *   attr2: {AutoLayout.Attribute},
         *   multiplier: {Number},
         *   constant: {Number},
         *   priority: {Number}(0..1000)
         * }
         * ```
         * @param {Array} constraints One or more constraint definitions.
         * @return {View} this
         */
        addConstraints(constraints) {
            for (var j = 0; j < constraints.length; j++) {
                this._addConstraint(constraints[j]);
            }
            this._solver.updateVariables();
            return this;
        }
        _addConstraint(constraint) {
            //this.constraints.push(constraint);
            let relation;
            const multiplier = constraint.multiplier !== undefined ? constraint.multiplier : 1;
            let constant = constraint.constant !== undefined ? constraint.constant : 0;
            if (constant === 'default') {
                constant = this._getSpacing(constraint);
            }
            const attr1 = this._getSubView(constraint.view1)._getAttr(constraint.attr1);
            let attr2;
            if (constraint.attr2 === Attribute.CONST) {
                attr2 = this._getConst(undefined, constraint.constant);
            }
            else {
                attr2 = this._getSubView(constraint.view2)._getAttr(constraint.attr2);
                if (multiplier !== 1 && constant) {
                    attr2 = attr2.multiply(multiplier).plus(constant);
                }
                else if (constant) {
                    attr2 = attr2.plus(constant);
                }
                else if (multiplier !== 1) {
                    attr2 = attr2.multiply(multiplier);
                }
            }
            const strength = constraint.priority !== undefined && constraint.priority < 1000
                ? kiwi.Strength.create(0, constraint.priority, 1000)
                : defaultPriorityStrength;
            switch (constraint.relation) {
                case Relation.EQU:
                    relation = new kiwi.Constraint(attr1, kiwi.Operator.Eq, attr2, strength);
                    break;
                case Relation.GEQ:
                    relation = new kiwi.Constraint(attr1, kiwi.Operator.Ge, attr2, strength);
                    break;
                case Relation.LEQ:
                    relation = new kiwi.Constraint(attr1, kiwi.Operator.Le, attr2, strength);
                    break;
                default:
                    throw 'Invalid relation specified: ' + constraint.relation;
            }
            this._solver.addConstraint(relation);
        }
        _getSpacing(constraint) {
            let index = 4;
            if (!constraint.view1 && constraint.attr1 === 'left') {
                index = 3;
            }
            else if (!constraint.view1 && constraint.attr1 === 'top') {
                index = 0;
            }
            else if (!constraint.view2 && constraint.attr2 === 'right') {
                index = 1;
            }
            else if (!constraint.view2 && constraint.attr2 === 'bottom') {
                index = 2;
            }
            else {
                switch (constraint.attr1) {
                    case 'left':
                    case 'right':
                    case 'centerX':
                    case 'leading':
                    case 'trailing':
                        index = 4;
                        break;
                    case 'zIndex':
                        index = 6;
                        break;
                    default:
                        index = 5;
                }
            }
            this._spacingVars = this._spacingVars || new Array(7);
            this._spacingExpr = this._spacingExpr || new Array(7);
            if (!this._spacingVars[index]) {
                this._spacingVars[index] = new kiwi.Variable();
                this._solver.addEditVariable(this._spacingVars[index], kiwi.Strength.create(999, 1000, 1000));
                this._spacingExpr[index] = this._spacingVars[index].multiply(-1);
                this._solver.suggestValue(this._spacingVars[index], this._spacing[index]);
            }
            return this._spacingExpr[index];
        }
        _getSubView(viewName) {
            if (!viewName) {
                return this._parentSubView;
            }
            else if (viewName.name) {
                this._subViews[viewName.name] =
                    this._subViews[viewName.name] ||
                        new SubView({
                            name: viewName.name,
                            solver: this._solver,
                        });
                this._subViews[viewName.name]._type = this._subViews[viewName.name]._type || viewName.type;
                return this._subViews[viewName.name];
            }
            else {
                this._subViews[viewName] =
                    this._subViews[viewName] ||
                        new SubView({
                            name: viewName,
                            solver: this._solver,
                        });
                return this._subViews[viewName];
            }
        }
        _getConst(name, value) {
            const vr = new kiwi.Variable();
            this._solver.addConstraint(new kiwi.Constraint(vr, kiwi.Operator.Eq, value));
            return vr;
        }
        /**
         * Dictionary of `SubView` objects that have been created when adding constraints.
         * @readonly
         * @type {Object.SubView}
         */
        get subViews() {
            return this._subViews;
        }
    }

    var AutoLayout = {
        Attribute,
        Relation,
        Priority,
        VisualFormat,
        View,
        SubView,
    };

    exports.Attribute = Attribute;
    exports.Priority = Priority;
    exports.Relation = Relation;
    exports.SubView = SubView;
    exports.View = View;
    exports.VisualFormat = VisualFormat;
    exports.default = AutoLayout;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
